Связный список.

Структура данных, представляющая собой конечное множество
упорядоченных элементов (узлов), связанных друг с другом
посредством указателей, называется связным списком. Каждый
элемент связного списка содержит поле с данными, а также
указатель (ссылку) на следующий и предыдущий элемент.
Эта структура позволяет эффективно выполнять операции
добавления и удаления элементов для любой позиции в
последовательности.

Причем это не потребует реорганизации структуры, которая бы
потребовалась в массиве. Минусом связного списка, как и
других структур типа «список», в сравнении его с массивом,
является отсутствие возможности работать с данными в режиме
произвольного доступа, т. е. список – структура
последовательно доступа, в то время как массив –
произвольного. Последний недостаток снижает эффективность
ряда операций.

Та особенность двусвязного списка, что каждый элемент имеет
две ссылки: на следующий и на предыдущий элемент, позволяет
двигаться как в его конец, так и в начало. Операции
добавления и удаления здесь наиболее эффективны, чем в
односвязном списке, поскольку всегда известны адреса тех
элементов списка, указатели которых направлены на
изменяемый элемент. Но добавление и удаление элемента в
двусвязном списке, требует изменения большого количества
ссылок, чем этого потребовал бы односвязный список.

Возможность двигаться как вперед, так и назад полезна для
выполнения некоторых операций, но дополнительные указатели
требуют задействования большего количества памяти, чем
таковой необходимо в односвязном списке.
+++
Реализация связного списка

Общая форма описания узла двунаправленного связного списка выглядит так:

struct имя_списка
{
информационное_поле_1;
информационное_поле_2;
…
информационное_поле_n;

указатель_на_следующий_элемент;
указатель_на_предыдущий_элемент;
};

Например определение узла двусвязного списка может выглядеть так:

struct node
{
int data;
node* next;
node* prev;
};
+++
Операции над списком: Добавление элемента.

bool insert(node *begin, size_t where, uint32_t data)
{
    while (begin && where)
    {
        begin = begin->next;
        where--;
    }
    if (!begin) return false;
    node *temp = node_init(data);
    temp->next = begin->next;
    temp->previous = begin;
    if (begin->next) begin->next->previous = temp;
    begin->next = temp;
    return true;
}

Как видно, функция принимает на вход начало списка, место,
где нужно добавить новый элемент и, собственно, сами данные.

Внутри тела функции есть цикл,который последовательно проходит
по всем узлам вплоть до узла под номером where. Это говорит о
том, что добавление
происходит за время O(N) 

Также в двусвязном списке нельзя добавить элемент в произвольном
месте, как это можно сделать в массиве, что говорит о том, что список - 
это структура не произвольного доступа.
+++
Операции над списком: Удаление элемента.
bool remove(node *begin, size_t where)
{
    while (begin && where)
    {
        begin = begin->next;
        where--;
    }
    if (!begin)
        return false;
    node *temp = begin;
    if (begin->previous)
        begin->previous->next = begin->next;
    if (begin->next)
        begin->next->previous = begin->previous;
    delete begin;
    return true;
}

Улаление элемента из списка происходит аналогично добавлению.
Операции выделения памяти противопоставляется операция высвобождения,
а узлы в месте удаления будут указывать друг на друга, а не на удаленный узел.
+++
Операции над списком: Просмотр значения узла.

bool at(node *begin, size_t where, uint32_t &result)
{
    while (begin && where)
    {
        begin = begin->next;
        where--;
    }
    if (!begin)
        return false;
    result = begin->data;
    return true;
}

Как видно, даже чтобы просто посомтреть значение необходимого узла нужно
пройти по всем узлам до него. Отсюда можно сделать вывод что операции удаления, 
добавления и итерации по списку происходят за время О(N)
+++
Операции над списком: Добавление/удаление элемента в начале списка.

void push_back(node *begin, uint32_t data)
{
    node* temp = node_init(data);
    temp->next = begin;
    begin = temp;
}

uint32_t pop_back(node *begin)
{
    uint32_t data = begin->data;
    node* temp = begin;
    begin = begin->next;
    delete temp;
    return data;
}

Как видно, в список все же можно добавлять элементы за константное время,
если вставка/удаление происходит в начало списка.